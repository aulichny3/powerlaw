// Copyright (c) 2025 Adam Ulichny
//
// This source code is licensed under the MIT OR Apache-2.0 license
// that can be found in the LICENSE-MIT or LICENSE-APACHE files
// at the root of this source tree.

use clap::{Parser, Subcommand};
use powerlaw::{Distribution, dist, util, stats};
use std::path::PathBuf;

#[derive(Parser)]
#[command(version, about = "A CLI tool for analyzing Power-Law distributed data.", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Fit a power-law distribution and find the best parameters (x_min, alpha)
    Fit {
        /// The path to the input data file (one value per line).
        #[arg(required = true)]
        filepath: PathBuf,
    },
    /// Test the hypothesis that the data follows a power-law distribution
    Test {
        /// The path to the input data file (one value per line).
        #[arg(required = true)]
        filepath: PathBuf,

        /// Sets the desired precision for the p-value calculation.
        #[arg(short, long, required = true)]
        precision: f64,
    },
}

fn main() {
    let cli = Cli::parse();

    match cli.command {
        Commands::Fit { filepath } => {
            run_analysis(filepath, None);
        }
        Commands::Test {
            filepath,
            precision,
        } => {
            run_analysis(filepath, Some(precision));
        }
    }
}

/// Runs the core Pareto Type I fit, with an optional hypothesis test.
fn run_analysis(filepath: PathBuf, precision: Option<f64>) {
    let file_path_str = filepath.to_str().unwrap_or("invalid path");

    // read data from csv into vector
    let mut X = util::read_csv(file_path_str).expect("Should be able to read the CSV file");

    // initial data check to cli only, library assumes the user understands x_min > 0.
    let mut data = util::check_data(&X);

    println!("Data: {}", file_path_str);
    if let Some(p) = precision {
        println!("Precision: {}", p);
    }
    println!("n: {}", data.len());

    // Step 1: test finding the MLE alphas for a given range of x_min and the data (Sec 3.1 Clauset et al.)
    let alphas = dist::pareto::find_alphas_fast(&mut data);

    // Step 2: gof KS test the cdf of the proposed x_min and alpha hat vs the sample with x >= x_min. (Sec 3.3 Clauset et al.)
    // this is to find the best x_min/alpha pair given the data

    let pareto_fit = dist::pareto::gof(&data, &alphas.0, &alphas.1);
    println!(
        "-- Pareto Type I parameters -- \nalpha:\t\t{:?} \nx_min:\t\t{:?} \nKS stat:\t{:?} \ntail length:\t{:?}",
        pareto_fit.alpha, pareto_fit.x_min, pareto_fit.d, pareto_fit.len_tail
    );
    println!("\n-- Generic Power-Law [Cx^(-alpha)] parameters -- \nalpha:\t\t{:?} \nx_min:\t\t{:?} \nKS stat:\t{:?} \ntail length:\t{:?}", pareto_fit.alpha + 1. , pareto_fit.x_min, pareto_fit.d, pareto_fit.len_tail);

    if let Some(prec) = precision {
        //calculate uncertainly of the estimates by generating synthetic datasets and finding the best fit for them (Sec 3.4 Clauset et al.)
        // this needs more work
        println!("\n-- Pareto Type I Parameter Uncertainty --");

        let (xm, a) = dist::pareto::estimation::param_est(&data, 100);
        println!("x_min std:\t{} \nalpha std:\t{}", xm, a);

        // Test the hypothesis that the sample data could have been generated by a pareto process (Sec 4.1 Clauset et al.)
        // this one is super slow
        println!(
            "\n-- Hypothesis Testing --"
        );
        let h_0 =
            dist::pareto::hypothesis_test(&data, prec, pareto_fit.alpha, pareto_fit.x_min, pareto_fit.d);
        println!(
            "Qty of simulations with KS statistic > empirical data = {:?}",
            h_0.gt
        );
        println!("p-value: {:?}", h_0.pval);

        // 0.1 was proposed by Clauset et al. as the level of significance by which to accept or reject H_0.
        if h_0.pval <= 0.1 {
            // reject the null H0 that the distributions are the same.
            println!("Reject the null H0: Power-Law distribution is unlikely to be a plausible fit to the data.")
        } else {
            // fail to reject the null H0 that the distributions are the same.
            println!("Fail to reject the null H0: Power-Law distribution is a plausible fit to the data.")
        }
    }   
    // Vuongs test for model selection
    let tail: Vec<f64> = data.iter().filter(|&x| x >= &pareto_fit.x_min).copied().collect();
    // fit an exponential distribution and compare the results with vuongs test
    let expo = dist::exponential::Exponential::from_fitment(&tail, &pareto_fit);
    
    //create a pareto based on our parameter estimates
    let pareto = dist::pareto::Pareto::from(pareto_fit);

    let dist1 = pareto.loglikelihood(&tail);
    let dist2 = expo.loglikelihood(&tail);

    let vuongs = stats::compare::vuongs_test(&dist1, &dist2);
    println!("\n-- Vuongs Closeness Test --");
    println!("Z score: {:?}", vuongs.0);
    println!("p-value: {:?}", vuongs.1);

    if (vuongs.1) <= 0.05 {
        println!("Pareto and Exponential models are significantly different.");
    } else {
        println!("No significant difference between Pareto and Exponential models.");
    }
}
